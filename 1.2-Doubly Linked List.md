A. Temel Yapı

```cpp
#include <iostream>
using namespace std;

struct DNode {
    int data;
    DNode* next;
    DNode* prev; // Geriye giden yol

    DNode(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};
```

B. Ekleme Operasyonları

```cpp
// 1. Başa Ekleme (Push Front)
void pushFront(DNode*& head, int newData) {
    DNode* newNode = new DNode(newData);
    
    newNode->next = head;
    newNode->prev = nullptr; // En baş olduğu için arkası boş
    
    if (head != nullptr) {
        head->prev = newNode; // Eski başın arkasına yeniyi bağla
    }
    head = newNode; // Head'i güncelle
}

// 2. Sona Ekleme (Push Back)
void pushBack(DNode*& head, int newData) {
    DNode* newNode = new DNode(newData);
    
    // Liste boşsa
    if (head == nullptr) {
        head = newNode;
        return;
    }
    
    // Sona kadar git
    DNode* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    
    // Bağlantıları kur
    temp->next = newNode; // Eskinin next'i -> yeni
    newNode->prev = temp; // Yeninin prev'i -> eski
}

// 3. Araya Ekleme (Insert After)
void insertAfter(DNode* prevNode, int newData) {
    if (prevNode == nullptr) return;
    
    DNode* newNode = new DNode(newData);
    
    newNode->next = prevNode->next;
    prevNode->next = newNode;
    newNode->prev = prevNode;
    
    // Eğer yeni düğümden sonra eleman varsa, onun prev'ini de güncelle
    if (newNode->next != nullptr) {
        newNode->next->prev = newNode;
    }
}
```
C. Silme Operasyonu
```cpp
void deleteNode(DNode*& head, int key) {
    DNode* temp = head;
    
    // Elemanı bul
    while (temp != nullptr && temp->data != key) {
        temp = temp->next;
    }
    
    if (temp == nullptr) return; // Bulunamadı
    
    // Eğer silinen baş ise
    if (temp == head) {
        head = temp->next;
    }
    
    // Eğer silinen son eleman DEĞİLSE (arkasında biri varsa)
    if (temp->next != nullptr) {
        temp->next->prev = temp->prev;
    }
    
    // Eğer silinen ilk eleman DEĞİLSE (önünde biri varsa)
    if (temp->prev != nullptr) {
        temp->prev->next = temp->next;
    }
    
    delete temp;
}
```

D. Sınavlık: Listeyi Ters Çevirme (Reverse Doubly)
```cpp
void reverseDoublyList(DNode*& head) {
    DNode* temp = nullptr;
    DNode* current = head;
    
    // Liste boşsa veya tek elemanlıysa işlem yapma
    if (head == nullptr || head->next == nullptr && head->prev == nullptr) return;

    while (current != nullptr) {
        // Swap işlemi (Prev ve Next yer değiştirir)
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;
        
        // Bir adım "geriye" git (aslında ileri gidiyoruz çünkü swap yaptık)
        current = current->prev; 
    }
    
    // Döngü bittiğinde 'temp' eski 2. düğümde kalır. 
    // Yeni head, temp'in prev'i (swap öncesi next'i) olur.
    if (temp != nullptr) {
        head = temp->prev;
    }
}
```
