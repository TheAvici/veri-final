Buradaki olay: next == nullptr diye bir şey yok. Son düğüm head'i gösterir. Döngülerde while(temp->next != head) kullanılır.

A. Temel Yapı
```cpp
// Tek yönlü node yapısının aynısı kullanılır
struct Node {
    int data;
    Node* next;
    Node(int val) { data = val; next = nullptr; }
};
```

B. Ekleme Operasyonları
Not: Dairesel listede başa ekleme yapmak için bile son düğümü bulup onun next pointer'ını yeni başa güncellemen gerekir. 
Bu yüzden pushFront bile O(N)'dir (Tail pointer tutmuyorsan).

```cpp
// 1. Başa Ekleme (Push Front)
void pushFrontCircular(Node*& head, int newData) {
    Node* newNode = new Node(newData);
    
    if (head == nullptr) {
        newNode->next = newNode; // Kendi kendini gösterir
        head = newNode;
        return;
    }
    
    // Son düğümü bul (Tail)
    Node* temp = head;
    while (temp->next != head) {
        temp = temp->next;
    }
    
    newNode->next = head; // Yeni -> Eski Baş
    temp->next = newNode; // Son -> Yeni Baş
    head = newNode;       // Head güncelle
}

// 2. Sona Ekleme (Push Back)
void pushBackCircular(Node*& head, int newData) {
    Node* newNode = new Node(newData);
    
    if (head == nullptr) {
        newNode->next = newNode;
        head = newNode;
        return;
    }
    
    Node* temp = head;
    while (temp->next != head) {
        temp = temp->next;
    }
    
    temp->next = newNode; // Eski son -> Yeni
    newNode->next = head; // Yeni -> Baş (Döngü tamamlandı)
}
```

C. Silme Operasyonu
Burada en gıcık durum Head'i silmektir, çünkü son düğümü bulup güncellemek gerekir.

```cpp
void deleteNodeCircular(Node*& head, int key) {
    if (head == nullptr) return;
    
    // DURUM 1: Liste tek elemanlıysa ve o silinecekse
    if (head->data == key && head->next == head) {
        delete head;
        head = nullptr;
        return;
    }
    
    Node* last = head;
    Node* d = head;
    
    // Head silinecekse: Önce son düğümü bulmalıyız
    if (head->data == key) {
        while (last->next != head) { // Son düğümü bul
            last = last->next;
        }
        last->next = head->next; // Son düğüm artık 2. elemanı göstersin
        delete head;
        head = last->next; // Head güncelle
        return;
    }
    
    // DURUM 2: Aradan veya sondan silme (Tek yönlü ile aynı mantık)
    while (d->next != head && d->next->data != key) {
        d = d->next;
    }
    
    // Eleman bulunduysa
    if (d->next->data == key) {
        Node* temp = d->next;
        d->next = temp->next;
        delete temp;
    }
}
```

D. Sınavlık: Listeyi Ters Çevirme (Reverse Circular)
Bu algoritma tek yönlü (Singly) ile neredeyse aynıdır (3 pointer kuralı: prev, current, next).
Tek fark en sonda bağlantıları tekrar daire haline getirmektir.

```cpp
void reverseCircularList(Node*& head) {
    if (head == nullptr || head->next == head) return; // Boş veya tek eleman
    
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;
    Node* last = head; 
    
    // Dairesel döngüde iterasyon (head'e geri dönene kadar)
    do {
        next = current->next; // Bağı kaybetme
        current->next = prev; // Oku ters çevir
        
        prev = current;
        current = next;
    } while (current != head);
    
    // Döngü bitince:
    // 1. Head'in next'i (eski head artık son eleman oldu), yeni başı (prev) göstermeli.
    head->next = prev;
    
    // 2. Head pointer'ını güncelle (prev artık yeni baştır)
    head = prev;
}
```
