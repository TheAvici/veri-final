1. Graf - Komşuluk Matrisi ile Düğüm Derecesi Bulma

Bu fonksiyon, matrisin ilgili satırını (u indeksli satırı) gezerek 1 olan sütunları sayar.
Bu, u düğümünden çıkan kenar sayısını (dereceyi) verir.

```cpp
// V: Köşe sayısı, adj: Komşuluk Matrisi (Adjacency Matrix)
int getDegree(int adj[][MAX], int V, int u) {
    int degree = 0;
    
    // u satırındaki tüm sütunları kontrol et
    for (int i = 0; i < V; i++) {
        // Eğer u ile i arasında kenar varsa (değer 1 ise)
        if (adj[u][i] == 1) {
            degree++;
        }
    }
    return degree;
}
```

2. Min-Heap - Yukarı Taşıma (Percolate Up / Heapify Up)


Yeni eklenen eleman (en sonda) parent (ebeveyn) düğümden küçük olduğu sürece yukarı taşınır. 
Bu işlem, kök düğüme ulaşana kadar veya kural sağlanana kadar devam eder.

```cpp
// heap[]: Heap dizisi, index: Yeni eklenen elemanın indisi
void percolateUp(int heap[], int index) {
    // Kök düğüme (0) gelene kadar devam et
    while (index > 0) {
        int parent = (index - 1) / 2; // Ebeveynin indisini bul
        
        // Min-Heap kuralı: Çocuk, ebeveyninden küçükse yer değiştir
        if (heap[index] < heap[parent]) {
            std::swap(heap[index], heap[parent]);
            index = parent; // Yeni konumdan yukarı tırmanmaya devam et
        } else {
            break; // Kural sağlanıyorsa döngüyü kır
        }
    }
}
```

3. Hash Table - Linear Probing ile Arama

Hash fonksiyonu ile hesaplanan indise bakılır. Eğer doluysa ve aranan değer değilse, 
boş bir yer (-1) bulana kadar veya başladığımız yere dönene kadar birer birer ilerlenir.

```cpp
// table[]: Hash tablosu, key: Aranan değer, size: Tablo boyutu
int searchLinearProbing(int table[], int size, int key) {
    int index = key % size; // Hash fonksiyonu ile başlangıç indisi
    int start = index;      // Başlangıç noktasını sakla (sonsuz döngü kontrolü)

    // -1 boş hücre anlamına gelir, boş görene kadar dön
    while (table[index] != -1) { 
        if (table[index] == key) {
            return index; // Değer bulundu, indisini döndür
        }
        
        // Bir sonraki hücreye bak (Linear Probing: i+1)
        index = (index + 1) % size;
        
        // Eğer başladığımız yere geri döndüysek tüm tablo taranmış demektir
        if (index == start) {
            break; 
        }
    }
    return -1; // Değer tabloda bulunamadı
}
```

4. Insertion Sort - While Döngüsü Kısmı

Eldeki key elemanını, sol taraftaki sıralı alt dizide doğru yere yerleştirmek için
kendinden büyük elemanları sağa kaydıran mantıktır.

```cpp
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i]; // Sıraya sokulacak elemanı seç
        int j = i - 1;

        // Kilit nokta: Key'den büyük olan sol taraftaki elemanları bir sağa kaydır
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // Kaydırma işlemi
            j = j - 1;           // Sola doğru ilerle
        }
        
        // Açılan boşluğa (veya doğru konuma) key'i yerleştir
        arr[j + 1] = key;
    }
}
```




