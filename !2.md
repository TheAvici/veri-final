1. Graflarda DFS (Derinlik Öncelikli Arama)

Soru: Komşuluk Listesi (Adjacency List) ile tutulan bir grafta, verilen bir düğümden başlayarak (recursive) DFS yapan fonksiyonu yazınız.

```cpp // selamlar aşkım 
// u: Şu anki düğüm
// adj: Komşuluk listesi (vector içinde vector)
// visited: Hangi düğüme gidildiğini tutan dizi
void DFS(int u, vector<vector<int>>& adj, vector<bool>& visited) {
    // 1. Önce geldiğimiz düğümü işaretle ve yaz
    visited[u] = true;
    cout << u << " ";

    // 2. Komşularını gez
    for (int v : adj[u]) {
        // Eğer komşu daha önce ziyaret edilmediyse, ona git (Recursion)
        if (!visited[v]) {
            DFS(v, adj, visited);
        }
    }
}
```

2. Hash Table - Quadratic Probing

Soru: Hash tablosunda çakışma (collision) olduğunda Quadratic Probing ($index + i^2$) yöntemini kullanan ekleme (insert) döngüsünü yazınız.

```cpp
// table: Tablo dizisi (-1 boş anlamına gelir)
// size: Tablo boyutu
// key: Eklenecek değer

int i = 0;
int index = key % size; // Hash fonksiyonu
int h = index;          // İlk bakılacak yer

// Hücre doluysa yeni yer ara (Collision Handling)
while (table[h] != -1) {
    i++;
    // Formül: (İlkIndex + i*i) % Boyut
    h = (index + i * i) % size;
    
    // Güvenlik önlemi: Tablo doluysa veya döngü çok uzarsa durdur
    if (i > size) break; 
}

// Boş yeri bulduk, değeri ekle
table[h] = key;
```

3. Selection Sort (Seçmeli Sıralama)

Soru: Selection Sort algoritmasında, her adımda dizinin sırasız kısmındaki en küçük elemanın indisini bulan iç döngüyü yazınız.

```cpp
// i: Dış döngünün o anki indisi (Sıralı kısmın bittiği, sırasızın başladığı yer)
int minIndex = i; // Şimdilik en küçük bu kabul edilir

// Sırasız kısmı tara
for (int j = i + 1; j < n; j++) {
    // Eğer o anki min'den daha küçüğünü bulursak, indisini güncelle
    if (arr[j] < arr[minIndex]) {
        minIndex = j;
    }
}

// Not: Bu döngüden sonra swap(arr[i], arr[minIndex]) işlemi yapılır.
```

-------------------------------------------------------------------------------------------------

Soru 4: Min-Heap'ten Eleman Silme (deleteMin)

Verilen Min-Heap: [2, 5, 12, 7, 6, 20, 15] (Heap yapısı: Kök=2, Sol=5, Sağ=12...)

İşlem: deleteMin() (En küçüğü sil)

Adım Adım Çözüm:

1- Kökü Sil ve Son Elemanı Taşı:

-En küçük eleman (2) silinir.

-Dizinin son elemanı (15) köke taşınır.

-Dizi: [15, 5, 12, 7, 6, 20]


2- Aşağı İndir (Percolate Down) - Adım 1:

-Kök (15) ile çocukları (5 ve 12) kıyaslanır.

-En küçük çocuk 5'tir. 15 > 5 olduğu için yer değiştirirler.

-Dizi: [5, 15, 12, 7, 6, 20]

3- Aşağı İndir (Percolate Down) - Adım 2:

-15 şimdi 1. indekste. Çocukları: 7 ve 6.

-En küçük çocuk 6'dır. 15 > 6 olduğu için yer değiştirirler.

-Dizi: [5, 6, 12, 7, 15, 20]


4- Sonuç:

-15'in artık çocuğu yok (veya varsa da onlardan küçük), işlem biter.

-Son Dizi: [5, 6, 12, 7, 15, 20]

-------------------------------------------------------------------------------------------------

Soru 5: Quick Sort (Partition Mantığı)

Dizi: [50, 20, 70, 10, 60, 30] Pivot: İlk eleman (50)

Soru: İlk "Partition" işlemi bittiğinde dizi nasıl görünür?

Çözüm Mantığı:

-Amaç: Pivotu (50) öyle bir yere koy ki; solundakiler 50'den küçük, sağındakiler 50'den büyük olsun.

-Küçükler: 20, 10, 30

-Büyükler: 70, 60

-Pivot: 50 

Olası Sonuç Dizisi: [30, 20, 10, 50, 60, 70]

(Not: Küçüklerin ve büyüklerin kendi içindeki sıralaması kullanılan partition algoritmasına -Lomuto veya Hoare- göre değişebilir ama 50 mutlaka 3. indekste (index 0, 1, 2, 3, 4, 5) olacaktır.)















